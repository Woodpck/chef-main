<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChefScript</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <header>
        <img src="{{ url_for('static', filename='logo.jpg') }}" alt="Header Image" class="header-image">
        <h1>ChefScript</h1>
    </header>
    <main class="layout-container">
        <!-- Loading overlay -->
        <div id="loading-overlay">
            <div class="spinner"></div>
        </div>

        <!-- Top section with input and errors side by side -->
        <div class="top-section">
            <div class="column input-area">
                <form id="codeForm" method="POST">
                    <div class="textarea-wrapper">
                        <div class="line-numbers" id="lineNumbers"></div>
                        <textarea name="code" id="codeTextarea" placeholder="Enter your code here..." oninput="updateLineNumbers()" onscroll="syncScroll()">{{ code }}</textarea>
                    </div>
                    <div class="button-container">
                        <button type="button" class="action-button" data-action="Run" id="runProgramButton">Run Program</button>
                    </div>
                </form>
            </div>
    
            <div class="column error-sections">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-button {% if active_tab == 'errors' %}active{% endif %}" onclick="showTab('errors')">ERRORS <span class="error-count" id="error-count">0</span></button>
                    <button class="tab-button {% if active_tab == 'output' %}active{% endif %}" onclick="showTab('output')">OUTPUT</button>
                </div>
            
                <!-- Errors Tab Content -->
                <div id="errors-tab" class="tab-content {% if active_tab == 'errors' %}active{% endif %}">
                    <div class="status-list">
                        <div class="status-item" id="lexical-status">
                            <span class="status-icon success">✓</span>
                            <span class="status-text">Success from Lexical</span>
                        </div>
                        <div class="status-item" id="syntax-status">
                            <span class="status-icon success">✓</span>
                            <span class="status-text">Success from Syntax</span>
                        </div>
                        <div class="status-item" id="semantic-status">
                            <span class="status-icon success">✓</span>
                            <span class="status-text">Success from Semantic</span>
                        </div>
                    </div>
                    
                    <div class="error-details" id="error-details">
                        <!-- Error details will appear here when there are errors -->
                        <div id="lexical-errors" class="success-message"></div>
                        <div id="syntax-errors" class="success-message"></div>
                        <div id="semantic-errors" class="success-message"></div>
                    </div>
                </div>
    
                <!-- Output Tab Content -->
                <div id="output-tab" class="tab-content {% if active_tab == 'output' %}active{% endif %}">
                    <div class="output-block">
                        <p id="output-content" class="{% if output_text %}output-message{% else %}no-output-message{% endif %}">
                            {% if output_text %}{{ output_text }} {% else %}No output generated yet{% endif %}
                        </p>
                        <p id="stats">

                        </p>
                    </div>
                </div>
            </div>
        </div>
    
        <!-- Result Table placed below input and error sections -->
        <div class="bottom-section">
            <div class="column result-table">
                <h2>Lexical and Token Table</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Lexeme</th>
                                <th>Token</th>
                            </tr>
                        </thead>
                        <tbody id="result-table-body">
                            {% if result and result|length > 0 %}
                                {% for lexeme, token in result %}
                                    <tr>
                                        <td>{{ lexeme }}</td>
                                        <td>{{ token }}</td>
                                    </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="2" class="no-results">No results yet</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Line number functions
        function updateLineNumbers() {
            const textarea = document.getElementById('codeTextarea');
            const lineNumbers = document.getElementById('lineNumbers');
            const lines = textarea.value.split('\n').length;
            lineNumbers.innerHTML = Array(lines).fill().map((_, i) => i + 1).join('<br>');
        }
        
        function syncScroll() {
            const textarea = document.getElementById('codeTextarea');
            const lineNumbers = document.getElementById('lineNumbers');
            lineNumbers.scrollTop = textarea.scrollTop;
        }
        
        // Tab switching
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show the selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Activate the clicked tab button
            document.querySelector(`.tab-button[onclick="showTab('${tabName}')"]`).classList.add('active');
        }
        
        // Update result table
        function updateResultTable(results) {
            const tableBody = document.getElementById('result-table-body');
            tableBody.innerHTML = '';
            
            if (results && results.length > 0) {
                results.forEach(result => {
                    const row = document.createElement('tr');
                    const lexemeCell = document.createElement('td');
                    const tokenCell = document.createElement('td');
                    
                    lexemeCell.textContent = result[0];
                    tokenCell.textContent = result[1];
                    
                    row.appendChild(lexemeCell);
                    row.appendChild(tokenCell);
                    tableBody.appendChild(row);
                });
            } else {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.className = 'no-results';
                cell.colSpan = 2;
                cell.textContent = 'No results yet';
                row.appendChild(cell);
                tableBody.appendChild(row);
            }
        }
        
        // Update error displays and status icons
        function updateErrorDisplay(elementId, errorText, isError) {
            const element = document.getElementById(elementId);
            
            if (isError) {
                element.className = 'error-message';
                element.textContent = errorText;
                
                // Update status icon based on error type
                const statusId = elementId.replace('-errors', '-status');
                const statusElement = document.getElementById(statusId);
                if (statusElement) {
                    const iconElement = statusElement.querySelector('.status-icon');
                    const textElement = statusElement.querySelector('.status-text');
                    
                    iconElement.className = 'status-icon error';
                    iconElement.textContent = '✗';
                    textElement.textContent = 'Error from ' + elementId.split('-')[0].charAt(0).toUpperCase() + elementId.split('-')[0].slice(1);
                }
                
                // Show error details section
                document.getElementById('error-details').style.display = 'block';
            } else {
                element.className = 'success-message';
                element.textContent = errorText;
                
                // Update status icon
                const statusId = elementId.replace('-errors', '-status');
                const statusElement = document.getElementById(statusId);
                if (statusElement) {
                    const iconElement = statusElement.querySelector('.status-icon');
                    const textElement = statusElement.querySelector('.status-text');
                    
                    iconElement.className = 'status-icon success';
                    iconElement.textContent = '✓';
                    textElement.textContent = 'Success from ' + elementId.split('-')[0].charAt(0).toUpperCase() + elementId.split('-')[0].slice(1);
                }
            }
            
            // Update error count badge
            updateErrorCount();
        }
        
        // Update error count
        function updateErrorCount() {
            const lexicalHasError = document.getElementById('lexical-errors').className === 'error-message';
            const syntaxHasError = document.getElementById('syntax-errors').className === 'error-message';
            const semanticHasError = document.getElementById('semantic-errors').className === 'error-message';
            
            const errorCount = (lexicalHasError ? 1 : 0) + (syntaxHasError ? 1 : 0) + (semanticHasError ? 1 : 0);
            document.getElementById('error-count').textContent = errorCount;
            
            // If no errors, hide error details section
            if (errorCount === 0) {
                document.getElementById('error-details').style.display = 'none';
            }
        }
        
        // Document ready
        document.addEventListener("DOMContentLoaded", function() {
            updateLineNumbers();
            updateErrorCount();
            
            const textarea = document.getElementById('codeTextarea');
            const form = document.getElementById('codeForm');
            const actionButtons = document.querySelectorAll('.action-button');
            const loadingOverlay = document.getElementById('loading-overlay');
            
            // Add click event for all action buttons
            actionButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Show loading overlay with transition
                    loadingOverlay.style.display = 'flex';
                    setTimeout(() => {
                        loadingOverlay.style.opacity = 1;
                    }, 10);
                    
                    // Get the action from button data attribute
                    const action = this.getAttribute('data-action');
                    
                    // Create form data
                    const formData = new FormData(form);
                    formData.append('action', action);
                    
                    // Perform AJAX request
                    fetch(window.location.href, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        // Update result table
                        updateResultTable(data.result);
                        
                        // Update error displays
                        updateErrorDisplay('lexical-errors', data.error_tokens_text, !!data.error_tokens_text);
                        updateErrorDisplay('syntax-errors', data.error_syntax_text, !!data.error_syntax_text);
                        updateErrorDisplay('semantic-errors', data.error_semantic_text, !!data.error_semantic_text);
                        
                        // Update output content
                        const outputElement = document.getElementById('output-content');
                        const statsElement = document.getElementById('stats');
                        if (data.time_execution){
                            statsElement.textContent = "Execution Time: " + data.time_execution.toFixed(2) + " second";
                        }
                        if (data.output_text) {
                            outputElement.className = 'output-message';
                            outputElement.textContent = data.output_text;
                        } else {
                            outputElement.className = 'no-output-message';
                            outputElement.textContent = 'No output generated yet';
                        }
                        
                        // Switch to active tab if provided
                        if (data.active_tab) {
                            showTab(data.active_tab);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while processing your request.');
                    })
                    .finally(() => {
                        // Hide loading overlay with transition
                        loadingOverlay.style.opacity = 0;
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 300);
                    });
                });
            });
            
            // Tab key handler
            textarea.addEventListener("keydown", function (event) {
                if (event.key === "Tab") {
                    event.preventDefault();
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const spaces = "    ";
                    textarea.value = textarea.value.substring(0, start) + spaces + textarea.value.substring(end);
                    textarea.selectionStart = textarea.selectionEnd = start + spaces.length;
                    
                    // Update line numbers after tab insertion
                    updateLineNumbers();
                }
                
                // Auto-closing for parentheses, braces, and quotes
                if (event.key === "(" || event.key === "{" || event.key === "\"" || event.key === "'") {
                    event.preventDefault();
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    
                    // Get the closing character
                    let closingChar;
                    if (event.key === "(") {
                        closingChar = ")";
                    } else if (event.key === "{") {
                        closingChar = "}";
                    } else { // For quotation marks (both single and double)
                        closingChar = event.key; // Same character for opening and closing
                    }
                    
                    // Insert opening char, selected text, and closing char
                    const selectedText = textarea.value.substring(start, end);
                    textarea.value = textarea.value.substring(0, start) + 
                                    event.key + selectedText + closingChar + 
                                    textarea.value.substring(end);
                    
                    // Position cursor appropriately
                    if (start === end) {
                        // If no text is selected, place cursor between the characters
                        textarea.selectionStart = textarea.selectionEnd = start + 1;
                    } else {
                        // If text is selected, place cursor after the closing character
                        textarea.selectionStart = textarea.selectionEnd = end + 2;
                    }
                    
                    // Update line numbers after inserting
                    updateLineNumbers();
                }
            });
            
            // Initialize line numbers on load
            updateLineNumbers();
        });
    </script>
    <!-- Add the new animation script here -->
<script>
// Add this function to your animations
function createMatrixRainEffect() {
    // Create matrix container if it doesn't exist
    let matrixContainer = document.querySelector('.matrix-effect');
    if (!matrixContainer) {
        matrixContainer = document.createElement('div');
        matrixContainer.className = 'matrix-effect';
        document.body.appendChild(matrixContainer);
    } else {
        // Clear existing content if refreshing
        matrixContainer.innerHTML = '';
    }
    
    // Screen width divided by column width gives number of columns
    const columnCount = Math.floor(window.innerWidth / 20);
    
    // Create columns
    for (let i = 0; i < columnCount; i++) {
        createMatrixColumn(matrixContainer, i * 20);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
        // Clear existing columns
        matrixContainer.innerHTML = '';
        
        // Recalculate column count
        const newColumnCount = Math.floor(window.innerWidth / 20);
        
        // Create new columns
        for (let i = 0; i < newColumnCount; i++) {
            createMatrixColumn(matrixContainer, i * 20);
        }
    });
}

function createMatrixColumn(container, posX) {
    const column = document.createElement('div');
    column.className = 'matrix-column';
    column.style.left = `${posX}px`;
    
    // Set random speed and start position
    const speed = Math.random() * 2 + 1; // 1-3
    const delay = Math.random() * 10000; // 0-10s delay
    
    // Set column content (random characters)
    const characters = "01";
    const columnHeight = Math.floor(window.innerHeight / 20); // Approximate character height
    
    // Populate column with characters
    let columnContent = '';
    for (let i = 0; i < columnHeight; i++) {
        const char = characters.charAt(Math.floor(Math.random() * characters.length));
        columnContent += `<span style="opacity: ${1 - (i / columnHeight)}">${char}</span><br>`;
    }
    
    column.innerHTML = columnContent;
    container.appendChild(column);
    
    // Animate column
    setTimeout(() => {
        let posY = -100;
        
        function moveColumn() {
            posY += speed;
            
            // Reset when it goes off screen
            if (posY > window.innerHeight + 100) {
                posY = -100;
                
                // Randomize content again
                let newContent = '';
                for (let i = 0; i < columnHeight; i++) {
                    const char = characters.charAt(Math.floor(Math.random() * characters.length));
                    newContent += `<span style="opacity: ${1 - (i / columnHeight)}">${char}</span><br>`;
                }
                column.innerHTML = newContent;
            }
            
            column.style.transform = `translateY(${posY}px)`;
            requestAnimationFrame(moveColumn);
        }
        
        moveColumn();
    }, delay);
}

// Add this to your existing document.addEventListener("DOMContentLoaded", function() { ... });
// after other animation setup
document.addEventListener("DOMContentLoaded", function() {
    // Call createMatrixRainEffect() to enable the matrix rain
    createMatrixRainEffect();
});
</script>

<script>

</script>
</body>
</html>